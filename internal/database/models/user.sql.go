// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addDigimonToTeam = `-- name: AddDigimonToTeam :exec
INSERT INTO user_team (user_id, digimon_id, team_slot)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, team_slot)
DO UPDATE SET digimon_id = EXCLUDED.digimon_id
`

type AddDigimonToTeamParams struct {
	UserID    uuid.UUID
	DigimonID pgtype.UUID
	TeamSlot  int32
}

func (q *Queries) AddDigimonToTeam(ctx context.Context, arg AddDigimonToTeamParams) error {
	_, err := q.db.Exec(ctx, addDigimonToTeam, arg.UserID, arg.DigimonID, arg.TeamSlot)
	return err
}

const addUserBits = `-- name: AddUserBits :exec
UPDATE user_resources
SET bits = bits + $2
WHERE user_id = $1
`

type AddUserBitsParams struct {
	UserID uuid.UUID
	Bits   pgtype.Int8
}

func (q *Queries) AddUserBits(ctx context.Context, arg AddUserBitsParams) error {
	_, err := q.db.Exec(ctx, addUserBits, arg.UserID, arg.Bits)
	return err
}

const checkUserChapterCompletion = `-- name: CheckUserChapterCompletion :one
SELECT COUNT(*) as total_stages,
    COUNT(ucs.stage_id) as completed_stages
FROM stages s
JOIN episodes e ON s.episode_id = e.id
LEFT JOIN user_completed_stages ucs ON s.id = ucs.stage_id AND ucs.user_id = $1
WHERE e.chapter_id = $2
ORDER BY e.chapter_id
`

type CheckUserChapterCompletionParams struct {
	UserID    uuid.UUID
	ChapterID pgtype.Int4
}

type CheckUserChapterCompletionRow struct {
	TotalStages     int64
	CompletedStages int64
}

func (q *Queries) CheckUserChapterCompletion(ctx context.Context, arg CheckUserChapterCompletionParams) (CheckUserChapterCompletionRow, error) {
	row := q.db.QueryRow(ctx, checkUserChapterCompletion, arg.UserID, arg.ChapterID)
	var i CheckUserChapterCompletionRow
	err := row.Scan(&i.TotalStages, &i.CompletedStages)
	return i, err
}

const clearTeamSlot = `-- name: ClearTeamSlot :exec
DELETE FROM user_team
WHERE user_id = $1 AND team_slot = $2
`

type ClearTeamSlotParams struct {
	UserID   uuid.UUID
	TeamSlot int32
}

func (q *Queries) ClearTeamSlot(ctx context.Context, arg ClearTeamSlotParams) error {
	_, err := q.db.Exec(ctx, clearTeamSlot, arg.UserID, arg.TeamSlot)
	return err
}

const completeStage = `-- name: CompleteStage :exec
INSERT INTO user_completed_stages (user_id, stage_id)
VALUES ($1, $2)
ON CONFLICT (user_id, stage_id) DO NOTHING
`

type CompleteStageParams struct {
	UserID  uuid.UUID
	StageID int32
}

func (q *Queries) CompleteStage(ctx context.Context, arg CompleteStageParams) error {
	_, err := q.db.Exec(ctx, completeStage, arg.UserID, arg.StageID)
	return err
}

const completeUserChapter = `-- name: CompleteUserChapter :exec
UPDATE user_chapter_progress
SET is_beaten = true, completed_at = NOW()
WHERE user_id = $1 AND chapter_id = $2
`

type CompleteUserChapterParams struct {
	UserID    uuid.UUID
	ChapterID int32
}

func (q *Queries) CompleteUserChapter(ctx context.Context, arg CompleteUserChapterParams) error {
	_, err := q.db.Exec(ctx, completeUserChapter, arg.UserID, arg.ChapterID)
	return err
}

const createPlayerResources = `-- name: CreatePlayerResources :exec
INSERT INTO user_resources (user_id)
VALUES ($1)
`

func (q *Queries) CreatePlayerResources(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, createPlayerResources, userID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username, password_hash
) VALUES ($1, $2) RETURNING id, username, password_hash, crated_at, updated_at, online
`

type CreateUserParams struct {
	Username     string
	PasswordHash string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
	)
	return i, err
}

const getCompletedStages = `-- name: GetCompletedStages :many
SELECT user_id, stage_id, completed_at FROM user_completed_stages WHERE user_id = $1
`

func (q *Queries) GetCompletedStages(ctx context.Context, userID uuid.UUID) ([]UserCompletedStage, error) {
	rows, err := q.db.Query(ctx, getCompletedStages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserCompletedStage
	for rows.Next() {
		var i UserCompletedStage
		if err := rows.Scan(&i.UserID, &i.StageID, &i.CompletedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, password_hash, crated_at, updated_at, online FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, crated_at, updated_at, online FROM users WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
	)
	return i, err
}

const getUserDigibank = `-- name: GetUserDigibank :many
SELECT ud.id, ud.user_id, ud.base_id, ud.nickname, ud.level, ud.exp, ud.friendship, ud.is_starter, ud.is_locked, ud.current_health, ud.current_mana, ud.health, ud.mana, ud.attack, ud.defense, ud.speed, ud.created_at, bd.id, bd.species, bd.base_health, bd.base_attack, bd.base_defense, bd.base_mana, bd.base_speed, bd.form, bd.attribute, bd.family, bd.element
FROM user_digibank ub
JOIN user_digimon ud ON ub.digimon_id = ud.id
JOIN base_digimon bd ON ud.base_id = bd.id
WHERE ub.user_id = $1
ORDER BY ub.bank_slot
`

type GetUserDigibankRow struct {
	ID            uuid.UUID
	UserID        pgtype.UUID
	BaseID        pgtype.Int4
	Nickname      pgtype.Text
	Level         pgtype.Int4
	Exp           pgtype.Int4
	Friendship    pgtype.Int4
	IsStarter     pgtype.Bool
	IsLocked      pgtype.Bool
	CurrentHealth pgtype.Int4
	CurrentMana   pgtype.Int4
	Health        pgtype.Int4
	Mana          pgtype.Int4
	Attack        pgtype.Int4
	Defense       pgtype.Int4
	Speed         pgtype.Int4
	CreatedAt     pgtype.Timestamp
	ID_2          int32
	Species       string
	BaseHealth    int32
	BaseAttack    int32
	BaseDefense   int32
	BaseMana      int32
	BaseSpeed     int32
	Form          string
	Attribute     string
	Family        string
	Element       string
}

func (q *Queries) GetUserDigibank(ctx context.Context, userID uuid.UUID) ([]GetUserDigibankRow, error) {
	rows, err := q.db.Query(ctx, getUserDigibank, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDigibankRow
	for rows.Next() {
		var i GetUserDigibankRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BaseID,
			&i.Nickname,
			&i.Level,
			&i.Exp,
			&i.Friendship,
			&i.IsStarter,
			&i.IsLocked,
			&i.CurrentHealth,
			&i.CurrentMana,
			&i.Health,
			&i.Mana,
			&i.Attack,
			&i.Defense,
			&i.Speed,
			&i.CreatedAt,
			&i.ID_2,
			&i.Species,
			&i.BaseHealth,
			&i.BaseAttack,
			&i.BaseDefense,
			&i.BaseMana,
			&i.BaseSpeed,
			&i.Form,
			&i.Attribute,
			&i.Family,
			&i.Element,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTeam = `-- name: GetUserTeam :many
SELECT ut.team_slot, ud.id, ud.user_id, ud.base_id, ud.nickname, ud.level, ud.exp, ud.friendship, ud.is_starter, ud.is_locked, ud.current_health, ud.current_mana, ud.health, ud.mana, ud.attack, ud.defense, ud.speed, ud.created_at, bd.id, bd.species, bd.base_health, bd.base_attack, bd.base_defense, bd.base_mana, bd.base_speed, bd.form, bd.attribute, bd.family, bd.element
FROM user_team ut
JOIN user_digimon ud ON ut.digimon_id = ud.id
JOIN base_digimon bd ON ud.base_id = bd.id
WHERE ut.user_id = $1
ORDER BY ut.team_slot
`

type GetUserTeamRow struct {
	TeamSlot      int32
	ID            uuid.UUID
	UserID        pgtype.UUID
	BaseID        pgtype.Int4
	Nickname      pgtype.Text
	Level         pgtype.Int4
	Exp           pgtype.Int4
	Friendship    pgtype.Int4
	IsStarter     pgtype.Bool
	IsLocked      pgtype.Bool
	CurrentHealth pgtype.Int4
	CurrentMana   pgtype.Int4
	Health        pgtype.Int4
	Mana          pgtype.Int4
	Attack        pgtype.Int4
	Defense       pgtype.Int4
	Speed         pgtype.Int4
	CreatedAt     pgtype.Timestamp
	ID_2          int32
	Species       string
	BaseHealth    int32
	BaseAttack    int32
	BaseDefense   int32
	BaseMana      int32
	BaseSpeed     int32
	Form          string
	Attribute     string
	Family        string
	Element       string
}

func (q *Queries) GetUserTeam(ctx context.Context, userID uuid.UUID) ([]GetUserTeamRow, error) {
	rows, err := q.db.Query(ctx, getUserTeam, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTeamRow
	for rows.Next() {
		var i GetUserTeamRow
		if err := rows.Scan(
			&i.TeamSlot,
			&i.ID,
			&i.UserID,
			&i.BaseID,
			&i.Nickname,
			&i.Level,
			&i.Exp,
			&i.Friendship,
			&i.IsStarter,
			&i.IsLocked,
			&i.CurrentHealth,
			&i.CurrentMana,
			&i.Health,
			&i.Mana,
			&i.Attack,
			&i.Defense,
			&i.Speed,
			&i.CreatedAt,
			&i.ID_2,
			&i.Species,
			&i.BaseHealth,
			&i.BaseAttack,
			&i.BaseDefense,
			&i.BaseMana,
			&i.BaseSpeed,
			&i.Form,
			&i.Attribute,
			&i.Family,
			&i.Element,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserUnlockedChapters = `-- name: GetUserUnlockedChapters :many
SELECT 
    c.id, c.chapter_name, c.chapter_number, c.description, c.is_unlocked, 
    COALESCE(ucp.is_beaten, false) as is_beaten
FROM chapters c
LEFT JOIN user_chapter_progress ucp ON c.id = ucp.chapter_id AND ucp.user_id = $1
WHERE c.id = 1
   OR COALESCE(ucp.is_unlocked, false) = true
ORDER BY c.chapter_number
`

type GetUserUnlockedChaptersRow struct {
	ID            int32
	ChapterName   string
	ChapterNumber string
	Description   pgtype.Text
	IsUnlocked    pgtype.Bool
	IsBeaten      bool
}

func (q *Queries) GetUserUnlockedChapters(ctx context.Context, userID uuid.UUID) ([]GetUserUnlockedChaptersRow, error) {
	rows, err := q.db.Query(ctx, getUserUnlockedChapters, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserUnlockedChaptersRow
	for rows.Next() {
		var i GetUserUnlockedChaptersRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterName,
			&i.ChapterNumber,
			&i.Description,
			&i.IsUnlocked,
			&i.IsBeaten,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithResources = `-- name: GetUserWithResources :one
SELECT u.id, u.username, u.password_hash, u.crated_at, u.updated_at, u.online, r.user_id, r.level, r.exp, r.stamina_current, r.stamina_max, r.bits, r.yen
FROM users u
LEFT JOIN user_resources r ON u.id = r.user_id
WHERE u.id = $1
`

type GetUserWithResourcesRow struct {
	ID             uuid.UUID
	Username       string
	PasswordHash   string
	CratedAt       pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	Online         pgtype.Bool
	UserID         pgtype.UUID
	Level          pgtype.Int4
	Exp            pgtype.Int4
	StaminaCurrent pgtype.Int4
	StaminaMax     pgtype.Int4
	Bits           pgtype.Int8
	Yen            pgtype.Int8
}

func (q *Queries) GetUserWithResources(ctx context.Context, id uuid.UUID) (GetUserWithResourcesRow, error) {
	row := q.db.QueryRow(ctx, getUserWithResources, id)
	var i GetUserWithResourcesRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
		&i.UserID,
		&i.Level,
		&i.Exp,
		&i.StaminaCurrent,
		&i.StaminaMax,
		&i.Bits,
		&i.Yen,
	)
	return i, err
}

const removeDigimonFromTeam = `-- name: RemoveDigimonFromTeam :exec
DELETE FROM user_team
WHERE user_id = $1 AND digimon_id = $2
`

type RemoveDigimonFromTeamParams struct {
	UserID    uuid.UUID
	DigimonID pgtype.UUID
}

func (q *Queries) RemoveDigimonFromTeam(ctx context.Context, arg RemoveDigimonFromTeamParams) error {
	_, err := q.db.Exec(ctx, removeDigimonFromTeam, arg.UserID, arg.DigimonID)
	return err
}

const unlockUserChapter = `-- name: UnlockUserChapter :exec
INSERT INTO user_chapter_progress (user_id, chapter_id, is_unlocked)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, chapter_id) 
DO UPDATE SET is_unlocked = true
`

type UnlockUserChapterParams struct {
	UserID     uuid.UUID
	ChapterID  int32
	IsUnlocked pgtype.Bool
}

func (q *Queries) UnlockUserChapter(ctx context.Context, arg UnlockUserChapterParams) error {
	_, err := q.db.Exec(ctx, unlockUserChapter, arg.UserID, arg.ChapterID, arg.IsUnlocked)
	return err
}
