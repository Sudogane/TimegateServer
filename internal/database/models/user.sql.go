// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addDigimonToTeam = `-- name: AddDigimonToTeam :exec
INSERT INTO user_team (user_id, digimon_id, team_slot)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, team_slot)
DO UPDATE SET digimon_id = EXCLUDED.digimon_id
`

type AddDigimonToTeamParams struct {
	UserID    uuid.UUID   `json:"user_id"`
	DigimonID pgtype.UUID `json:"digimon_id"`
	TeamSlot  int32       `json:"team_slot"`
}

func (q *Queries) AddDigimonToTeam(ctx context.Context, arg AddDigimonToTeamParams) error {
	_, err := q.db.Exec(ctx, addDigimonToTeam, arg.UserID, arg.DigimonID, arg.TeamSlot)
	return err
}

const addUserBits = `-- name: AddUserBits :exec
UPDATE user_resources
SET bits = bits + $2
WHERE user_id = $1
`

type AddUserBitsParams struct {
	UserID uuid.UUID   `json:"user_id"`
	Bits   pgtype.Int8 `json:"bits"`
}

func (q *Queries) AddUserBits(ctx context.Context, arg AddUserBitsParams) error {
	_, err := q.db.Exec(ctx, addUserBits, arg.UserID, arg.Bits)
	return err
}

const checkUserChapterCompletion = `-- name: CheckUserChapterCompletion :one
SELECT COUNT(*) as total_stages,
    COUNT(ucs.stage_id) as completed_stages
FROM stages s
JOIN episodes e ON s.episode_id = e.id
LEFT JOIN user_completed_stages ucs ON s.id = ucs.stage_id AND ucs.user_id = $1
WHERE e.chapter_id = $2
ORDER BY e.chapter_id
`

type CheckUserChapterCompletionParams struct {
	UserID    uuid.UUID   `json:"user_id"`
	ChapterID pgtype.Int4 `json:"chapter_id"`
}

type CheckUserChapterCompletionRow struct {
	TotalStages     int64 `json:"total_stages"`
	CompletedStages int64 `json:"completed_stages"`
}

func (q *Queries) CheckUserChapterCompletion(ctx context.Context, arg CheckUserChapterCompletionParams) (CheckUserChapterCompletionRow, error) {
	row := q.db.QueryRow(ctx, checkUserChapterCompletion, arg.UserID, arg.ChapterID)
	var i CheckUserChapterCompletionRow
	err := row.Scan(&i.TotalStages, &i.CompletedStages)
	return i, err
}

const clearTeamSlot = `-- name: ClearTeamSlot :exec
DELETE FROM user_team
WHERE user_id = $1 AND team_slot = $2
`

type ClearTeamSlotParams struct {
	UserID   uuid.UUID `json:"user_id"`
	TeamSlot int32     `json:"team_slot"`
}

func (q *Queries) ClearTeamSlot(ctx context.Context, arg ClearTeamSlotParams) error {
	_, err := q.db.Exec(ctx, clearTeamSlot, arg.UserID, arg.TeamSlot)
	return err
}

const completeStage = `-- name: CompleteStage :exec
INSERT INTO user_completed_stages (user_id, stage_id)
VALUES ($1, $2)
ON CONFLICT (user_id, stage_id) DO NOTHING
`

type CompleteStageParams struct {
	UserID  uuid.UUID `json:"user_id"`
	StageID int32     `json:"stage_id"`
}

func (q *Queries) CompleteStage(ctx context.Context, arg CompleteStageParams) error {
	_, err := q.db.Exec(ctx, completeStage, arg.UserID, arg.StageID)
	return err
}

const completeUserChapter = `-- name: CompleteUserChapter :exec
UPDATE user_chapter_progress
SET is_beaten = true, completed_at = NOW()
WHERE user_id = $1 AND chapter_id = $2
`

type CompleteUserChapterParams struct {
	UserID    uuid.UUID `json:"user_id"`
	ChapterID int32     `json:"chapter_id"`
}

func (q *Queries) CompleteUserChapter(ctx context.Context, arg CompleteUserChapterParams) error {
	_, err := q.db.Exec(ctx, completeUserChapter, arg.UserID, arg.ChapterID)
	return err
}

const createPlayerResources = `-- name: CreatePlayerResources :exec
INSERT INTO user_resources (user_id)
VALUES ($1)
`

func (q *Queries) CreatePlayerResources(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, createPlayerResources, userID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username, password_hash
) VALUES ($1, $2) RETURNING id, username, password_hash, crated_at, updated_at, online
`

type CreateUserParams struct {
	Username     string `json:"username"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.PasswordHash)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
	)
	return i, err
}

const getCompletedStages = `-- name: GetCompletedStages :many
SELECT user_id, stage_id, completed_at FROM user_completed_stages WHERE user_id = $1
`

func (q *Queries) GetCompletedStages(ctx context.Context, userID uuid.UUID) ([]UserCompletedStage, error) {
	rows, err := q.db.Query(ctx, getCompletedStages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserCompletedStage
	for rows.Next() {
		var i UserCompletedStage
		if err := rows.Scan(&i.UserID, &i.StageID, &i.CompletedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, username, password_hash, crated_at, updated_at, online FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, crated_at, updated_at, online FROM users WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
	)
	return i, err
}

const getUserDigibank = `-- name: GetUserDigibank :many
SELECT ud.id, ud.user_id, ud.base_id, ud.nickname, ud.level, ud.exp, ud.friendship, ud.is_starter, ud.is_locked, ud.current_health, ud.current_mana, ud.health, ud.mana, ud.attack, ud.defense, ud.speed, ud.created_at, bd.id, bd.species, bd.base_health, bd.base_attack, bd.base_defense, bd.base_mana, bd.base_speed, bd.form, bd.attribute, bd.family, bd.element
FROM user_digibank ub
JOIN user_digimon ud ON ub.digimon_id = ud.id
JOIN base_digimon bd ON ud.base_id = bd.id
WHERE ub.user_id = $1
ORDER BY ub.bank_slot
`

type GetUserDigibankRow struct {
	ID            uuid.UUID        `json:"id"`
	UserID        pgtype.UUID      `json:"user_id"`
	BaseID        pgtype.Int4      `json:"base_id"`
	Nickname      pgtype.Text      `json:"nickname"`
	Level         pgtype.Int4      `json:"level"`
	Exp           pgtype.Int4      `json:"exp"`
	Friendship    pgtype.Int4      `json:"friendship"`
	IsStarter     pgtype.Bool      `json:"is_starter"`
	IsLocked      pgtype.Bool      `json:"is_locked"`
	CurrentHealth pgtype.Int4      `json:"current_health"`
	CurrentMana   pgtype.Int4      `json:"current_mana"`
	Health        pgtype.Int4      `json:"health"`
	Mana          pgtype.Int4      `json:"mana"`
	Attack        pgtype.Int4      `json:"attack"`
	Defense       pgtype.Int4      `json:"defense"`
	Speed         pgtype.Int4      `json:"speed"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	ID_2          int32            `json:"id_2"`
	Species       string           `json:"species"`
	BaseHealth    int32            `json:"base_health"`
	BaseAttack    int32            `json:"base_attack"`
	BaseDefense   int32            `json:"base_defense"`
	BaseMana      int32            `json:"base_mana"`
	BaseSpeed     int32            `json:"base_speed"`
	Form          string           `json:"form"`
	Attribute     string           `json:"attribute"`
	Family        string           `json:"family"`
	Element       string           `json:"element"`
}

func (q *Queries) GetUserDigibank(ctx context.Context, userID uuid.UUID) ([]GetUserDigibankRow, error) {
	rows, err := q.db.Query(ctx, getUserDigibank, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDigibankRow
	for rows.Next() {
		var i GetUserDigibankRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BaseID,
			&i.Nickname,
			&i.Level,
			&i.Exp,
			&i.Friendship,
			&i.IsStarter,
			&i.IsLocked,
			&i.CurrentHealth,
			&i.CurrentMana,
			&i.Health,
			&i.Mana,
			&i.Attack,
			&i.Defense,
			&i.Speed,
			&i.CreatedAt,
			&i.ID_2,
			&i.Species,
			&i.BaseHealth,
			&i.BaseAttack,
			&i.BaseDefense,
			&i.BaseMana,
			&i.BaseSpeed,
			&i.Form,
			&i.Attribute,
			&i.Family,
			&i.Element,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTeam = `-- name: GetUserTeam :many
SELECT ut.team_slot, ud.id, ud.user_id, ud.base_id, ud.nickname, ud.level, ud.exp, ud.friendship, ud.is_starter, ud.is_locked, ud.current_health, ud.current_mana, ud.health, ud.mana, ud.attack, ud.defense, ud.speed, ud.created_at, bd.id, bd.species, bd.base_health, bd.base_attack, bd.base_defense, bd.base_mana, bd.base_speed, bd.form, bd.attribute, bd.family, bd.element
FROM user_team ut
JOIN user_digimon ud ON ut.digimon_id = ud.id
JOIN base_digimon bd ON ud.base_id = bd.id
WHERE ut.user_id = $1
ORDER BY ut.team_slot
`

type GetUserTeamRow struct {
	TeamSlot      int32            `json:"team_slot"`
	ID            uuid.UUID        `json:"id"`
	UserID        pgtype.UUID      `json:"user_id"`
	BaseID        pgtype.Int4      `json:"base_id"`
	Nickname      pgtype.Text      `json:"nickname"`
	Level         pgtype.Int4      `json:"level"`
	Exp           pgtype.Int4      `json:"exp"`
	Friendship    pgtype.Int4      `json:"friendship"`
	IsStarter     pgtype.Bool      `json:"is_starter"`
	IsLocked      pgtype.Bool      `json:"is_locked"`
	CurrentHealth pgtype.Int4      `json:"current_health"`
	CurrentMana   pgtype.Int4      `json:"current_mana"`
	Health        pgtype.Int4      `json:"health"`
	Mana          pgtype.Int4      `json:"mana"`
	Attack        pgtype.Int4      `json:"attack"`
	Defense       pgtype.Int4      `json:"defense"`
	Speed         pgtype.Int4      `json:"speed"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	ID_2          int32            `json:"id_2"`
	Species       string           `json:"species"`
	BaseHealth    int32            `json:"base_health"`
	BaseAttack    int32            `json:"base_attack"`
	BaseDefense   int32            `json:"base_defense"`
	BaseMana      int32            `json:"base_mana"`
	BaseSpeed     int32            `json:"base_speed"`
	Form          string           `json:"form"`
	Attribute     string           `json:"attribute"`
	Family        string           `json:"family"`
	Element       string           `json:"element"`
}

func (q *Queries) GetUserTeam(ctx context.Context, userID uuid.UUID) ([]GetUserTeamRow, error) {
	rows, err := q.db.Query(ctx, getUserTeam, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTeamRow
	for rows.Next() {
		var i GetUserTeamRow
		if err := rows.Scan(
			&i.TeamSlot,
			&i.ID,
			&i.UserID,
			&i.BaseID,
			&i.Nickname,
			&i.Level,
			&i.Exp,
			&i.Friendship,
			&i.IsStarter,
			&i.IsLocked,
			&i.CurrentHealth,
			&i.CurrentMana,
			&i.Health,
			&i.Mana,
			&i.Attack,
			&i.Defense,
			&i.Speed,
			&i.CreatedAt,
			&i.ID_2,
			&i.Species,
			&i.BaseHealth,
			&i.BaseAttack,
			&i.BaseDefense,
			&i.BaseMana,
			&i.BaseSpeed,
			&i.Form,
			&i.Attribute,
			&i.Family,
			&i.Element,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserUnlockedChapters = `-- name: GetUserUnlockedChapters :many
SELECT 
    c.id, c.chapter_name, c.chapter_number, c.description, c.is_unlocked, 
    COALESCE(ucp.is_beaten, false) as is_beaten
FROM chapters c
LEFT JOIN user_chapter_progress ucp ON c.id = ucp.chapter_id AND ucp.user_id = $1
WHERE c.id = 1
   OR COALESCE(ucp.is_unlocked, false) = true
ORDER BY c.chapter_number
`

type GetUserUnlockedChaptersRow struct {
	ID            int32       `json:"id"`
	ChapterName   string      `json:"chapter_name"`
	ChapterNumber string      `json:"chapter_number"`
	Description   pgtype.Text `json:"description"`
	IsUnlocked    pgtype.Bool `json:"is_unlocked"`
	IsBeaten      bool        `json:"is_beaten"`
}

func (q *Queries) GetUserUnlockedChapters(ctx context.Context, userID uuid.UUID) ([]GetUserUnlockedChaptersRow, error) {
	rows, err := q.db.Query(ctx, getUserUnlockedChapters, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserUnlockedChaptersRow
	for rows.Next() {
		var i GetUserUnlockedChaptersRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterName,
			&i.ChapterNumber,
			&i.Description,
			&i.IsUnlocked,
			&i.IsBeaten,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithResources = `-- name: GetUserWithResources :one
SELECT u.id, u.username, u.password_hash, u.crated_at, u.updated_at, u.online, r.user_id, r.level, r.exp, r.stamina_current, r.stamina_max, r.bits, r.yen
FROM users u
LEFT JOIN user_resources r ON u.id = r.user_id
WHERE u.id = $1
`

type GetUserWithResourcesRow struct {
	ID             uuid.UUID        `json:"id"`
	Username       string           `json:"username"`
	PasswordHash   string           `json:"password_hash"`
	CratedAt       pgtype.Timestamp `json:"crated_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Online         pgtype.Bool      `json:"online"`
	UserID         pgtype.UUID      `json:"user_id"`
	Level          pgtype.Int4      `json:"level"`
	Exp            pgtype.Int4      `json:"exp"`
	StaminaCurrent pgtype.Int4      `json:"stamina_current"`
	StaminaMax     pgtype.Int4      `json:"stamina_max"`
	Bits           pgtype.Int8      `json:"bits"`
	Yen            pgtype.Int8      `json:"yen"`
}

func (q *Queries) GetUserWithResources(ctx context.Context, id uuid.UUID) (GetUserWithResourcesRow, error) {
	row := q.db.QueryRow(ctx, getUserWithResources, id)
	var i GetUserWithResourcesRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.CratedAt,
		&i.UpdatedAt,
		&i.Online,
		&i.UserID,
		&i.Level,
		&i.Exp,
		&i.StaminaCurrent,
		&i.StaminaMax,
		&i.Bits,
		&i.Yen,
	)
	return i, err
}

const removeDigimonFromTeam = `-- name: RemoveDigimonFromTeam :exec
DELETE FROM user_team
WHERE user_id = $1 AND digimon_id = $2
`

type RemoveDigimonFromTeamParams struct {
	UserID    uuid.UUID   `json:"user_id"`
	DigimonID pgtype.UUID `json:"digimon_id"`
}

func (q *Queries) RemoveDigimonFromTeam(ctx context.Context, arg RemoveDigimonFromTeamParams) error {
	_, err := q.db.Exec(ctx, removeDigimonFromTeam, arg.UserID, arg.DigimonID)
	return err
}

const unlockUserChapter = `-- name: UnlockUserChapter :exec
INSERT INTO user_chapter_progress (user_id, chapter_id, is_unlocked)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, chapter_id) 
DO UPDATE SET is_unlocked = true
`

type UnlockUserChapterParams struct {
	UserID     uuid.UUID   `json:"user_id"`
	ChapterID  int32       `json:"chapter_id"`
	IsUnlocked pgtype.Bool `json:"is_unlocked"`
}

func (q *Queries) UnlockUserChapter(ctx context.Context, arg UnlockUserChapterParams) error {
	_, err := q.db.Exec(ctx, unlockUserChapter, arg.UserID, arg.ChapterID, arg.IsUnlocked)
	return err
}
