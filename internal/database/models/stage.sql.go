// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stage.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAvailableEpisodesByChapterId = `-- name: GetAvailableEpisodesByChapterId :many
SELECT e.id, e.chapter_id, e.episode_number, e.episode_name
FROM episodes e
WHERE e.id = 1 AND e.chapter_id = $1
    OR EXISTS (
        SELECT 1 FROM user_episode_progress uep
        JOIN episodes prev_ep ON prev_ep.episode_number = e.episode_number - 1 
        AND prev_ep.chapter_id = e.chapter_id
        WHERE uep.user_id = $2 AND uep.episode_id = prev_ep.id
    )
ORDER BY e.episode_number
`

type GetAvailableEpisodesByChapterIdParams struct {
	ChapterID pgtype.Int4 `json:"chapter_id"`
	UserID    uuid.UUID   `json:"user_id"`
}

func (q *Queries) GetAvailableEpisodesByChapterId(ctx context.Context, arg GetAvailableEpisodesByChapterIdParams) ([]Episode, error) {
	rows, err := q.db.Query(ctx, getAvailableEpisodesByChapterId, arg.ChapterID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.EpisodeNumber,
			&i.EpisodeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableStages = `-- name: GetAvailableStages :many
SELECT s.id, s.chapter_id, s.episode_id, s.stage_number, s.stage_name, s.description, s.defeat_stage_id, s.tamer_level, s.drop_bits, s.drop_exp, s.drop_sexp, s.max_waves, s.stage_type, e.episode_name, c.chapter_name
FROM stages s
JOIN episodes e ON s.episode_id = e.id
JOIN chapters c ON e.chapter_id = c.id
WHERE s.defeat_stage_id IS NULL
    OR EXISTS (
        SELECT 1 FROM user_completed_stages 
        WHERE user_id = $1 AND stage_id = s.defeat_stage_id
    )
ORDER BY c.chapter_number, e.episode_number, s.stage_number
`

type GetAvailableStagesRow struct {
	ID            int32       `json:"id"`
	ChapterID     pgtype.Int4 `json:"chapter_id"`
	EpisodeID     pgtype.Int4 `json:"episode_id"`
	StageNumber   int32       `json:"stage_number"`
	StageName     string      `json:"stage_name"`
	Description   pgtype.Text `json:"description"`
	DefeatStageID pgtype.Int4 `json:"defeat_stage_id"`
	TamerLevel    pgtype.Int4 `json:"tamer_level"`
	DropBits      pgtype.Int4 `json:"drop_bits"`
	DropExp       pgtype.Int4 `json:"drop_exp"`
	DropSexp      pgtype.Int4 `json:"drop_sexp"`
	MaxWaves      pgtype.Int4 `json:"max_waves"`
	StageType     pgtype.Text `json:"stage_type"`
	EpisodeName   string      `json:"episode_name"`
	ChapterName   string      `json:"chapter_name"`
}

func (q *Queries) GetAvailableStages(ctx context.Context, userID uuid.UUID) ([]GetAvailableStagesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableStages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableStagesRow
	for rows.Next() {
		var i GetAvailableStagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.EpisodeID,
			&i.StageNumber,
			&i.StageName,
			&i.Description,
			&i.DefeatStageID,
			&i.TamerLevel,
			&i.DropBits,
			&i.DropExp,
			&i.DropSexp,
			&i.MaxWaves,
			&i.StageType,
			&i.EpisodeName,
			&i.ChapterName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableStagesByEpisodeId = `-- name: GetAvailableStagesByEpisodeId :many
SELECT s.id, s.chapter_id, s.episode_id, s.stage_number, s.stage_name, s.description, s.defeat_stage_id, s.tamer_level, s.drop_bits, s.drop_exp, s.drop_sexp, s.max_waves, s.stage_type
FROM stages s
WHERE s.episode_id = $1
  AND (
    s.defeat_stage_id IS NULL 
    OR EXISTS (
      SELECT 1 FROM user_completed_stages 
      WHERE user_id = $2
        AND stage_id = s.defeat_stage_id
    )
  )
ORDER BY s.stage_number
`

type GetAvailableStagesByEpisodeIdParams struct {
	EpisodeID pgtype.Int4 `json:"episode_id"`
	UserID    uuid.UUID   `json:"user_id"`
}

func (q *Queries) GetAvailableStagesByEpisodeId(ctx context.Context, arg GetAvailableStagesByEpisodeIdParams) ([]Stage, error) {
	rows, err := q.db.Query(ctx, getAvailableStagesByEpisodeId, arg.EpisodeID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stage
	for rows.Next() {
		var i Stage
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.EpisodeID,
			&i.StageNumber,
			&i.StageName,
			&i.Description,
			&i.DefeatStageID,
			&i.TamerLevel,
			&i.DropBits,
			&i.DropExp,
			&i.DropSexp,
			&i.MaxWaves,
			&i.StageType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStageById = `-- name: GetStageById :one
SELECT s.id, s.chapter_id, s.episode_id, s.stage_number, s.stage_name, s.description, s.defeat_stage_id, s.tamer_level, s.drop_bits, s.drop_exp, s.drop_sexp, s.max_waves, s.stage_type, e.episode_name, c.chapter_name
FROM stages s
JOIN episodes e ON s.episode_id = e.id
JOIN chapters c ON s.chapter_id = c.id
WHERE s.id = $1
`

type GetStageByIdRow struct {
	ID            int32       `json:"id"`
	ChapterID     pgtype.Int4 `json:"chapter_id"`
	EpisodeID     pgtype.Int4 `json:"episode_id"`
	StageNumber   int32       `json:"stage_number"`
	StageName     string      `json:"stage_name"`
	Description   pgtype.Text `json:"description"`
	DefeatStageID pgtype.Int4 `json:"defeat_stage_id"`
	TamerLevel    pgtype.Int4 `json:"tamer_level"`
	DropBits      pgtype.Int4 `json:"drop_bits"`
	DropExp       pgtype.Int4 `json:"drop_exp"`
	DropSexp      pgtype.Int4 `json:"drop_sexp"`
	MaxWaves      pgtype.Int4 `json:"max_waves"`
	StageType     pgtype.Text `json:"stage_type"`
	EpisodeName   string      `json:"episode_name"`
	ChapterName   string      `json:"chapter_name"`
}

func (q *Queries) GetStageById(ctx context.Context, id int32) (GetStageByIdRow, error) {
	row := q.db.QueryRow(ctx, getStageById, id)
	var i GetStageByIdRow
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.EpisodeID,
		&i.StageNumber,
		&i.StageName,
		&i.Description,
		&i.DefeatStageID,
		&i.TamerLevel,
		&i.DropBits,
		&i.DropExp,
		&i.DropSexp,
		&i.MaxWaves,
		&i.StageType,
		&i.EpisodeName,
		&i.ChapterName,
	)
	return i, err
}

const getStageWaves = `-- name: GetStageWaves :many
SELECT sw.id, sw.stage_id, sw.wave_number, we.id, we.wave_id, we.enemy_slot, we.enemy_id, we.enemy_level, bd.id, bd.species, bd.base_health, bd.base_attack, bd.base_defense, bd.base_mana, bd.base_speed, bd.form, bd.attribute, bd.family, bd.element
FROM stage_waves sw
LEFT JOIN wave_enemies we ON sw.id = we.id
LEFT JOIN base_digimon bd ON we.enemy_id = bd.id
WHERE sw.id = $1
ORDER BY sw.wave_number, we.enemy_slot
`

type GetStageWavesRow struct {
	ID          int32       `json:"id"`
	StageID     pgtype.Int4 `json:"stage_id"`
	WaveNumber  int32       `json:"wave_number"`
	ID_2        pgtype.Int4 `json:"id_2"`
	WaveID      pgtype.Int4 `json:"wave_id"`
	EnemySlot   pgtype.Int4 `json:"enemy_slot"`
	EnemyID     pgtype.Int4 `json:"enemy_id"`
	EnemyLevel  pgtype.Int4 `json:"enemy_level"`
	ID_3        pgtype.Int4 `json:"id_3"`
	Species     pgtype.Text `json:"species"`
	BaseHealth  pgtype.Int4 `json:"base_health"`
	BaseAttack  pgtype.Int4 `json:"base_attack"`
	BaseDefense pgtype.Int4 `json:"base_defense"`
	BaseMana    pgtype.Int4 `json:"base_mana"`
	BaseSpeed   pgtype.Int4 `json:"base_speed"`
	Form        pgtype.Text `json:"form"`
	Attribute   pgtype.Text `json:"attribute"`
	Family      pgtype.Text `json:"family"`
	Element     pgtype.Text `json:"element"`
}

func (q *Queries) GetStageWaves(ctx context.Context, id int32) ([]GetStageWavesRow, error) {
	rows, err := q.db.Query(ctx, getStageWaves, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStageWavesRow
	for rows.Next() {
		var i GetStageWavesRow
		if err := rows.Scan(
			&i.ID,
			&i.StageID,
			&i.WaveNumber,
			&i.ID_2,
			&i.WaveID,
			&i.EnemySlot,
			&i.EnemyID,
			&i.EnemyLevel,
			&i.ID_3,
			&i.Species,
			&i.BaseHealth,
			&i.BaseAttack,
			&i.BaseDefense,
			&i.BaseMana,
			&i.BaseSpeed,
			&i.Form,
			&i.Attribute,
			&i.Family,
			&i.Element,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
