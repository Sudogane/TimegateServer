// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: digimon.sql

package models

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUserDigimon = `-- name: CreateUserDigimon :one
INSERT INTO user_digimon (user_id, base_id, is_starter, is_locked) VALUES ($1, $2, $3, $4) RETURNING id, user_id, base_id, species, nickname, level, exp, friendship, is_starter, is_locked, current_health, current_mana, health, mana, attack, defense, speed, created_at
`

type CreateUserDigimonParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	BaseID    pgtype.Int4 `json:"base_id"`
	IsStarter pgtype.Bool `json:"is_starter"`
	IsLocked  pgtype.Bool `json:"is_locked"`
}

func (q *Queries) CreateUserDigimon(ctx context.Context, arg CreateUserDigimonParams) (UserDigimon, error) {
	row := q.db.QueryRow(ctx, createUserDigimon,
		arg.UserID,
		arg.BaseID,
		arg.IsStarter,
		arg.IsLocked,
	)
	var i UserDigimon
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseID,
		&i.Species,
		&i.Nickname,
		&i.Level,
		&i.Exp,
		&i.Friendship,
		&i.IsStarter,
		&i.IsLocked,
		&i.CurrentHealth,
		&i.CurrentMana,
		&i.Health,
		&i.Mana,
		&i.Attack,
		&i.Defense,
		&i.Speed,
		&i.CreatedAt,
	)
	return i, err
}

const getAllBaseDigimon = `-- name: GetAllBaseDigimon :many
SELECT id, species, base_health, base_attack, base_defense, base_mana, base_speed, form, attribute, family, element FROM base_digimon ORDER BY species
`

func (q *Queries) GetAllBaseDigimon(ctx context.Context) ([]BaseDigimon, error) {
	rows, err := q.db.Query(ctx, getAllBaseDigimon)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BaseDigimon
	for rows.Next() {
		var i BaseDigimon
		if err := rows.Scan(
			&i.ID,
			&i.Species,
			&i.BaseHealth,
			&i.BaseAttack,
			&i.BaseDefense,
			&i.BaseMana,
			&i.BaseSpeed,
			&i.Form,
			&i.Attribute,
			&i.Family,
			&i.Element,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserDigimon = `-- name: GetAllUserDigimon :many
SELECT id, user_id, base_id, species, nickname, level, exp, friendship, is_starter, is_locked, current_health, current_mana, health, mana, attack, defense, speed, created_at FROM user_digimon WHERE id = $1
`

func (q *Queries) GetAllUserDigimon(ctx context.Context, id uuid.UUID) ([]UserDigimon, error) {
	rows, err := q.db.Query(ctx, getAllUserDigimon, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserDigimon
	for rows.Next() {
		var i UserDigimon
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BaseID,
			&i.Species,
			&i.Nickname,
			&i.Level,
			&i.Exp,
			&i.Friendship,
			&i.IsStarter,
			&i.IsLocked,
			&i.CurrentHealth,
			&i.CurrentMana,
			&i.Health,
			&i.Mana,
			&i.Attack,
			&i.Defense,
			&i.Speed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBaseDigimon = `-- name: GetBaseDigimon :one
SELECT id, species, base_health, base_attack, base_defense, base_mana, base_speed, form, attribute, family, element FROM base_digimon WHERE id = $1
`

func (q *Queries) GetBaseDigimon(ctx context.Context, id int32) (BaseDigimon, error) {
	row := q.db.QueryRow(ctx, getBaseDigimon, id)
	var i BaseDigimon
	err := row.Scan(
		&i.ID,
		&i.Species,
		&i.BaseHealth,
		&i.BaseAttack,
		&i.BaseDefense,
		&i.BaseMana,
		&i.BaseSpeed,
		&i.Form,
		&i.Attribute,
		&i.Family,
		&i.Element,
	)
	return i, err
}

const getBaseDigimonBySpecies = `-- name: GetBaseDigimonBySpecies :one
SELECT id, species, base_health, base_attack, base_defense, base_mana, base_speed, form, attribute, family, element FROM base_digimon WHERE species = $1
`

func (q *Queries) GetBaseDigimonBySpecies(ctx context.Context, species string) (BaseDigimon, error) {
	row := q.db.QueryRow(ctx, getBaseDigimonBySpecies, species)
	var i BaseDigimon
	err := row.Scan(
		&i.ID,
		&i.Species,
		&i.BaseHealth,
		&i.BaseAttack,
		&i.BaseDefense,
		&i.BaseMana,
		&i.BaseSpeed,
		&i.Form,
		&i.Attribute,
		&i.Family,
		&i.Element,
	)
	return i, err
}

const getUserDigimon = `-- name: GetUserDigimon :one
SELECT id, user_id, base_id, species, nickname, level, exp, friendship, is_starter, is_locked, current_health, current_mana, health, mana, attack, defense, speed, created_at FROM user_digimon WHERE id = $1 AND user_id = $2
`

type GetUserDigimonParams struct {
	ID     uuid.UUID   `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetUserDigimon(ctx context.Context, arg GetUserDigimonParams) (UserDigimon, error) {
	row := q.db.QueryRow(ctx, getUserDigimon, arg.ID, arg.UserID)
	var i UserDigimon
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseID,
		&i.Species,
		&i.Nickname,
		&i.Level,
		&i.Exp,
		&i.Friendship,
		&i.IsStarter,
		&i.IsLocked,
		&i.CurrentHealth,
		&i.CurrentMana,
		&i.Health,
		&i.Mana,
		&i.Attack,
		&i.Defense,
		&i.Speed,
		&i.CreatedAt,
	)
	return i, err
}

const getUserDigimonByStarterFlag = `-- name: GetUserDigimonByStarterFlag :one
SELECT id, user_id, base_id, species, nickname, level, exp, friendship, is_starter, is_locked, current_health, current_mana, health, mana, attack, defense, speed, created_at FROM user_digimon WHERE user_id = $1 AND is_starter = true LIMIT 1
`

func (q *Queries) GetUserDigimonByStarterFlag(ctx context.Context, userID pgtype.UUID) (UserDigimon, error) {
	row := q.db.QueryRow(ctx, getUserDigimonByStarterFlag, userID)
	var i UserDigimon
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BaseID,
		&i.Species,
		&i.Nickname,
		&i.Level,
		&i.Exp,
		&i.Friendship,
		&i.IsStarter,
		&i.IsLocked,
		&i.CurrentHealth,
		&i.CurrentMana,
		&i.Health,
		&i.Mana,
		&i.Attack,
		&i.Defense,
		&i.Speed,
		&i.CreatedAt,
	)
	return i, err
}
